// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: users.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createUser = `-- name: CreateUser :one
INSERT INTO
    users(username, password, email)
VALUES
($1, $2, $3) RETURNING id, username, password, email, created_at, last_login
`

type CreateUserParams struct {
	Username string
	Password string
	Email    string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Username, arg.Password, arg.Email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Email,
		&i.CreatedAt,
		&i.LastLogin,
	)
	return i, err
}

const createUserProfile = `-- name: CreateUserProfile :one
/*  
    USER PROFILE
*/

INSERT INTO
    user_profile(user_id, phone_number, address)
VALUES
($1, $2, $3) RETURNING id, user_id, phone_number, address, is_verified
`

type CreateUserProfileParams struct {
	UserID      int32
	PhoneNumber string
	Address     string
}

func (q *Queries) CreateUserProfile(ctx context.Context, arg CreateUserProfileParams) (UserProfile, error) {
	row := q.db.QueryRow(ctx, createUserProfile, arg.UserID, arg.PhoneNumber, arg.Address)
	var i UserProfile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PhoneNumber,
		&i.Address,
		&i.IsVerified,
	)
	return i, err
}

const findUser = `-- name: FindUser :one
SELECT users.id, username, password, email, created_at, last_login, user_profile.id, user_id, phone_number, address, is_verified FROM users INNER JOIN user_profile ON users.id = user_profile.user_id 
WHERE users.username = $1 OR users.email = $1 OR user_profile.phone_number = $1
`

type FindUserRow struct {
	ID          int32
	Username    string
	Password    string
	Email       string
	CreatedAt   pgtype.Timestamp
	LastLogin   pgtype.Timestamp
	ID_2        int32
	UserID      int32
	PhoneNumber string
	Address     string
	IsVerified  bool
}

func (q *Queries) FindUser(ctx context.Context, username string) (FindUserRow, error) {
	row := q.db.QueryRow(ctx, findUser, username)
	var i FindUserRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Email,
		&i.CreatedAt,
		&i.LastLogin,
		&i.ID_2,
		&i.UserID,
		&i.PhoneNumber,
		&i.Address,
		&i.IsVerified,
	)
	return i, err
}

const getAllUsersData = `-- name: GetAllUsersData :many
/*
    JOINS
*/

SELECT users.id, username, password, email, created_at, last_login, user_profile.id, user_id, phone_number, address, is_verified FROM users INNER JOIN user_profile ON users.id = user_profile.user_id
`

type GetAllUsersDataRow struct {
	ID          int32
	Username    string
	Password    string
	Email       string
	CreatedAt   pgtype.Timestamp
	LastLogin   pgtype.Timestamp
	ID_2        int32
	UserID      int32
	PhoneNumber string
	Address     string
	IsVerified  bool
}

func (q *Queries) GetAllUsersData(ctx context.Context) ([]GetAllUsersDataRow, error) {
	rows, err := q.db.Query(ctx, getAllUsersData)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUsersDataRow
	for rows.Next() {
		var i GetAllUsersDataRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Password,
			&i.Email,
			&i.CreatedAt,
			&i.LastLogin,
			&i.ID_2,
			&i.UserID,
			&i.PhoneNumber,
			&i.Address,
			&i.IsVerified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSingleUserData = `-- name: GetSingleUserData :one
SELECT users.id, username, password, email, created_at, last_login, user_profile.id, user_id, phone_number, address, is_verified FROM users INNER JOIN user_profile ON users.id = user_profile.user_id WHERE users.id = $1
`

type GetSingleUserDataRow struct {
	ID          int32
	Username    string
	Password    string
	Email       string
	CreatedAt   pgtype.Timestamp
	LastLogin   pgtype.Timestamp
	ID_2        int32
	UserID      int32
	PhoneNumber string
	Address     string
	IsVerified  bool
}

func (q *Queries) GetSingleUserData(ctx context.Context, id int32) (GetSingleUserDataRow, error) {
	row := q.db.QueryRow(ctx, getSingleUserData, id)
	var i GetSingleUserDataRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Email,
		&i.CreatedAt,
		&i.LastLogin,
		&i.ID_2,
		&i.UserID,
		&i.PhoneNumber,
		&i.Address,
		&i.IsVerified,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, username, password, email, created_at, last_login FROM users WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Email,
		&i.CreatedAt,
		&i.LastLogin,
	)
	return i, err
}

const getUserById = `-- name: GetUserById :one
SELECT id, username, password, email, created_at, last_login FROM users WHERE id = $1
`

func (q *Queries) GetUserById(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRow(ctx, getUserById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Email,
		&i.CreatedAt,
		&i.LastLogin,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, password, email, created_at, last_login FROM users WHERE username = $1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Email,
		&i.CreatedAt,
		&i.LastLogin,
	)
	return i, err
}

const getUserIdFromPhone = `-- name: GetUserIdFromPhone :one
SELECT user_id FROM user_profile WHERE phone_number = $1
`

func (q *Queries) GetUserIdFromPhone(ctx context.Context, phoneNumber string) (int32, error) {
	row := q.db.QueryRow(ctx, getUserIdFromPhone, phoneNumber)
	var user_id int32
	err := row.Scan(&user_id)
	return user_id, err
}

const getUserProfileInfo = `-- name: GetUserProfileInfo :one
SELECT id, user_id, phone_number, address, is_verified FROM user_profile WHERE user_id = $1
`

func (q *Queries) GetUserProfileInfo(ctx context.Context, userID int32) (UserProfile, error) {
	row := q.db.QueryRow(ctx, getUserProfileInfo, userID)
	var i UserProfile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PhoneNumber,
		&i.Address,
		&i.IsVerified,
	)
	return i, err
}

const getUsers = `-- name: GetUsers :many
SELECT id, username, password, email, created_at, last_login FROM users ORDER BY id
`

func (q *Queries) GetUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.Query(ctx, getUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Password,
			&i.Email,
			&i.CreatedAt,
			&i.LastLogin,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const loginWithUserId = `-- name: LoginWithUserId :one
SELECT users.id, username, password, email, created_at, last_login, user_profile.id, user_id, phone_number, address, is_verified FROM users INNER JOIN user_profile ON users.id = user_profile.user_id 
WHERE users.id = $1 AND users.password = $2
`

type LoginWithUserIdParams struct {
	ID       int32
	Password string
}

type LoginWithUserIdRow struct {
	ID          int32
	Username    string
	Password    string
	Email       string
	CreatedAt   pgtype.Timestamp
	LastLogin   pgtype.Timestamp
	ID_2        int32
	UserID      int32
	PhoneNumber string
	Address     string
	IsVerified  bool
}

func (q *Queries) LoginWithUserId(ctx context.Context, arg LoginWithUserIdParams) (LoginWithUserIdRow, error) {
	row := q.db.QueryRow(ctx, loginWithUserId, arg.ID, arg.Password)
	var i LoginWithUserIdRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Email,
		&i.CreatedAt,
		&i.LastLogin,
		&i.ID_2,
		&i.UserID,
		&i.PhoneNumber,
		&i.Address,
		&i.IsVerified,
	)
	return i, err
}

const updatePassword = `-- name: UpdatePassword :one
UPDATE users SET password = $2 WHERE id = $1 RETURNING id, username, password, email, created_at, last_login
`

type UpdatePasswordParams struct {
	ID       int32
	Password string
}

func (q *Queries) UpdatePassword(ctx context.Context, arg UpdatePasswordParams) (User, error) {
	row := q.db.QueryRow(ctx, updatePassword, arg.ID, arg.Password)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Email,
		&i.CreatedAt,
		&i.LastLogin,
	)
	return i, err
}

const updateUserAddress = `-- name: UpdateUserAddress :one
UPDATE user_profile SET address = $2 WHERE user_id = $1 RETURNING id, user_id, phone_number, address, is_verified
`

type UpdateUserAddressParams struct {
	UserID  int32
	Address string
}

func (q *Queries) UpdateUserAddress(ctx context.Context, arg UpdateUserAddressParams) (UserProfile, error) {
	row := q.db.QueryRow(ctx, updateUserAddress, arg.UserID, arg.Address)
	var i UserProfile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PhoneNumber,
		&i.Address,
		&i.IsVerified,
	)
	return i, err
}

const updateUserEmail = `-- name: UpdateUserEmail :one
UPDATE users SET email = $2 WHERE id = $1 RETURNING id, username, password, email, created_at, last_login
`

type UpdateUserEmailParams struct {
	ID    int32
	Email string
}

func (q *Queries) UpdateUserEmail(ctx context.Context, arg UpdateUserEmailParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserEmail, arg.ID, arg.Email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Email,
		&i.CreatedAt,
		&i.LastLogin,
	)
	return i, err
}

const updateUserLastLogin = `-- name: UpdateUserLastLogin :one
UPDATE users SET last_login = $2 WHERE id = $1 RETURNING id, username, password, email, created_at, last_login
`

type UpdateUserLastLoginParams struct {
	ID        int32
	LastLogin pgtype.Timestamp
}

func (q *Queries) UpdateUserLastLogin(ctx context.Context, arg UpdateUserLastLoginParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserLastLogin, arg.ID, arg.LastLogin)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Email,
		&i.CreatedAt,
		&i.LastLogin,
	)
	return i, err
}

const updateUserPhone = `-- name: UpdateUserPhone :one
UPDATE user_profile SET phone_number = $2 WHERE user_id = $1 RETURNING id, user_id, phone_number, address, is_verified
`

type UpdateUserPhoneParams struct {
	UserID      int32
	PhoneNumber string
}

func (q *Queries) UpdateUserPhone(ctx context.Context, arg UpdateUserPhoneParams) (UserProfile, error) {
	row := q.db.QueryRow(ctx, updateUserPhone, arg.UserID, arg.PhoneNumber)
	var i UserProfile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PhoneNumber,
		&i.Address,
		&i.IsVerified,
	)
	return i, err
}

const updateUsername = `-- name: UpdateUsername :one
UPDATE users SET username = $2 WHERE id = $1 RETURNING id, username, password, email, created_at, last_login
`

type UpdateUsernameParams struct {
	ID       int32
	Username string
}

func (q *Queries) UpdateUsername(ctx context.Context, arg UpdateUsernameParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUsername, arg.ID, arg.Username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Email,
		&i.CreatedAt,
		&i.LastLogin,
	)
	return i, err
}

const verifyUser = `-- name: VerifyUser :one
UPDATE user_profile SET is_verified = $2 WHERE user_id = $1 RETURNING id, user_id, phone_number, address, is_verified
`

type VerifyUserParams struct {
	UserID     int32
	IsVerified bool
}

func (q *Queries) VerifyUser(ctx context.Context, arg VerifyUserParams) (UserProfile, error) {
	row := q.db.QueryRow(ctx, verifyUser, arg.UserID, arg.IsVerified)
	var i UserProfile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PhoneNumber,
		&i.Address,
		&i.IsVerified,
	)
	return i, err
}
